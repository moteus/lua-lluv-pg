io.stdout:setvbuf'no';io.stderr:setvbuf'no';
package.path = "..\\src\\?.lua;" .. package.path

local prequire = function(m)
  local ok, m = pcall(require, m)
  if ok then return m end
end

local uv   = require "lluv"
local pg   = require "lluv.pg"
local loop = require "lluv.busted.loop"
local stp  = prequire"StackTracePlus"

setloop(loop)

loop.set_timeout(5)

loop.set_traceback(stp and stp.stacktrace or debug.traceback)

local CONFIG = {
  database = os.getenv'LLUV_PG_DBNAME' or 'test',
  user     = os.getenv'LLUV_PG_DBUSER' or 'postgres',
  password = os.getenv'LLUV_PG_DBPASS' or '',
}

local assert_nil     = assert.is_nil

local TEST_TABLE_NAME = 'test'
local DEFINITION_STRING_TYPE_NAME = 'text'
local TOTAL_FIELDS = 5

local function define_table(n)
  local t = {}
  for i = 1, n do
    table.insert (t, "f"..i.." "..DEFINITION_STRING_TYPE_NAME)
  end
  return "create table " .. TEST_TABLE_NAME .. " ("..table.concat (t, ',')..")"
end

local function create_table (cnn, cb)
  cnn:query(define_table(TOTAL_FIELDS), cb)
end

local function drop_table(cnn, cb)
  cnn:query('drop table ' .. TEST_TABLE_NAME, cb)
end

local function table_exists(cnn, cb)
  cnn:query('select TOP 1 form ' .. TEST_TABLE_NAME, function(self, err)
    cb(cnn, not not err)
  end)
end

local function ensure_table(cnn, cb)
  table_exists(cnn, function(self, bool)
    if bool then drop_table(self, function() end) end
    create_table(self, function(self, err) assert_nil(err)
      cb()
    end)
  end)
end

describe('pg connect', function()
  local cnn

  it('should connect', function(done) async()
    local events = {}
    cnn:connect(function(self, err)
      assert.equal(cnn, self)
      assert_nil(err)
      assert.same({'open', 'ready'}, events)
      done()
    end)

    cnn:on('open',function(self, event)
      assert.equal(cnn, self)
      events[#events + 1] = event
    end)

    cnn:on('ready',function(self, event)
      assert.equal(cnn, self)
      events[#events + 1] = event
    end)
  end)

  it('should pass settings', function(done) async()
    local events = {}
    --! @fixme do not use private fields
    assert.table(cnn._pg_opt)
    assert.equal(CONFIG.database, cnn._pg_opt.database)
    cnn._pg_opt.application_name = 'lluv-pg'

    cnn:connect(function(self, err)
      assert.equal(cnn, self)
      assert_nil(err)
      assert.same({'open', 'ready'}, events)
      done()
    end)

    cnn:on('open',function(self, event)
      assert.equal(cnn, self)
      events[#events + 1] = event
    end)

    cnn:on('ready',function(self, event, settings)
      assert.equal(cnn, self)
      assert.equal('lluv-pg', settings.application_name)
      events[#events + 1] = event
    end)
  end)

  it('should fail create connection withoud database', function(done) async()
    assert.error(function() pg.new{} end)
    done()
  end)

  it('should fail connect to unknown database', function(done) async()
    --! @fixme do not use private fields
    assert.table(cnn._pg_opt)
    assert.equal(CONFIG.database, cnn._pg_opt.database)
    cnn._pg_opt.database = CONFIG.database .. '-unknown'

    local events = {}

    cnn:connect(function(self, err)
      assert.equal(cnn, self) assert.not_nil(err)
      assert.same({'open', 'error'}, events)
      done()
    end)

    cnn:on('open',function(self, event)
      assert.equal(cnn, self)
      events[#events + 1] = event
    end)

    cnn:on('ready',function(self, event, status)
      assert.equal(cnn, self)
      assert.table(status)
      events[#events + 1] = event
    end)

    cnn:on('error',function(self, event, err)
      assert.equal(cnn, self)
      assert.not_nil(err)
      events[#events + 1] = event
    end)

  end)

  before_each(function(done) async()
    cnn = pg.new(CONFIG)
    done()
  end)

  after_each(function(done) async()
    if cnn then
      cnn:close(function() done() end)
      cnn = nil
      return
    end
    done()
  end)
end)

describe('pg query', function()
  local cnn

  it('should execute simple query with single recordset and single row', function(done) async()
    local sql = "select 'hello' as f1, 'world' as f2"
    cnn:query(sql, function(self, err, recordset, count)
      assert.equal(cnn, self) assert_nil(err)
      assert.equal(1, count)
      assert.same({
        header = {{'f1', 'f2'}, {'string', 'string'}};
        {'hello', 'world'};
      }, recordset)
      done()
    end)
  end)

  it('should execute simple query with rows affected', function(done) async()
    local sql = "insert into " .. TEST_TABLE_NAME .. "(f1, f2) values('hello', 'world')"
    cnn:query(sql, function(self, err, recordset, count)
      assert.equal(cnn, self) assert_nil(err)
      assert.equal(1, count)
      assert.same({1}, recordset)
      done()
    end)
  end)

  it('should execute 2 simple query one by one', function(done) async()
    local called = false
  
    local sql = "select 'hello' as f1, 'world' as f2"
    cnn:query(sql, function(self, err, recordset, count)
      assert.equal(cnn, self) assert_nil(err)
      assert.equal(1, count)
      assert.same({
        header = {{'f1', 'f2'}, {'string', 'string'}};
        {'hello', 'world'};
      }, recordset)
      called = true
    end)

    local sql = "select 'hi' as f2, 'again' as f3"
    cnn:query(sql, function(self, err, recordset, count)
      assert.equal(cnn, self) assert_nil(err)
      assert.equal(1, count)
      assert.same({
        header = {{'f2', 'f3'}, {'string', 'string'}};
        {'hi', 'again'};
      }, recordset)
      assert.truthy(called)
      done()
    end)
  end)

  it('should execute second simple query after error', function(done) async()
    local called = false
  
    local sql = "select 1 form not_a_table"
    cnn:query(sql, function(self, err, recordset, count)
      assert.equal(cnn, self) assert.not_nil(err)
      called = true
    end)

    local sql = "select 'hi' as f2, 'again' as f3"
    cnn:query(sql, function(self, err, recordset, count)
      assert.equal(cnn, self) assert_nil(err)
      assert.equal(1, count)
      assert.same({
        header = {{'f2', 'f3'}, {'string', 'string'}};
        {'hi', 'again'};
      }, recordset)
      assert.truthy(called)
      done()
    end)
  end)

  it('should execute simple query with single recordset and multiple rows', function(done) async()
    local sql = "select 'hello' as f1, 'world' as f2"
    local sql = sql .. " union all " .. sql
    cnn:query(sql, function(self, err, recordset, count)
      assert.equal(cnn, self) assert_nil(err)
      assert.equal(1, count)
      assert.same({
        header = {{'f1', 'f2'}, {'string', 'string'}};
        {'hello', 'world'};
        {'hello', 'world'};
      }, recordset)
      done()
    end)
  end)

  it('should execute simple query with multiple recordsets', function(done) async()
    local sql1 = "select 'hello' as f1, 'world' as f2"
    local sql2 = "select 1 as f3, 2.3::float4 as f4"
    local sql = sql1 .. ";" .. sql2
    cnn:query(sql, function(self, err, recordset, count)
      assert.equal(cnn, self) assert_nil(err)
      assert.equal(2, count)
      assert.same({
        { -- first recordset
          header = {{'f1', 'f2'}, {'string', 'string'}};
          {'hello', 'world'};
        },
        { -- second recordset
          header = {{'f3', 'f4'}, {'integer', 'number'}};
          {'1', '2.3'};
        }
      }, recordset)
      done()
    end)
  end)

  it('should execute simple query with multiple recordsets with empty results', function(done) async()
    local sql1 = "select 'hello' as f1, 'world' as f2"
    local sql2 = "select 1 as f3, 2.3::float4 as f4 where 1=0"
    local sql3 = "select 2 as f3, 3.3::float4 as f4"
    local sql = sql1 .. ";" .. sql2 .. ";" .. sql3
    cnn:query(sql, function(self, err, recordset, count)
      assert.equal(cnn, self) assert_nil(err)
      assert.equal(3, count)
      assert.same({
        { -- first recordset
          header = {{'f1', 'f2'}, {'string', 'string'}};
          {'hello', 'world'};
        },
        { -- second (empty) recordset
          header = {{'f3', 'f4'}, {'integer', 'number'}};
        },
        { -- third recordset
          header = {{'f3', 'f4'}, {'integer', 'number'}};
          {'2', '3.3'};
        }
      }, recordset)
      done()
    end)
  end)

  it('should execute simple query with multiple recordsets with errors', function(done) async()
    local sql1 = "select 'hello' as f1, 'world' as f2"
    local sql2 = "select 1 as f3, 2.3::float4 as f4"
    local sql3 = "select * from not_a_table"
    local sql4 = "select 2 as f3, 3.3::float4 as f4"
    local sql = sql1 .. ";" .. sql2 .. ";" .. sql3 .. ";" .. sql4
    cnn:query(sql, function(self, err, recordset, count)
      assert.equal(cnn, self)
      assert.not_nil(err)     -- we get error on third query
      assert.equal(2, count)
      assert.same({
        { -- first recordset
          header = {{'f1', 'f2'}, {'string', 'string'}};
          {'hello', 'world'};
        },
        { -- second recordset
          header = {{'f3', 'f4'}, {'integer', 'number'}};
          {'1', '2.3'};
        }
      }, recordset)
      done()
    end)
  end)

  it('should execute simple query with recordset and rows affected', function(done) async()
    local sql1 = "select 'hello' as f1, 'world' as f2"
    local sql2 = "update " .. TEST_TABLE_NAME .. " set f1 = 'hello'"
    local sql = sql1 .. ";" .. sql2

    cnn:query(sql, function(self, err, recordset, count)
      assert.equal(cnn, self) assert_nil(err)
      assert.equal(2, count)
      assert.same({
        { -- first recordset
          header = {{'f1', 'f2'}, {'string', 'string'}};
          {'hello', 'world'};
        },
        { -- second results (rows affected)
          0
        }
      }, recordset)
      done()
    end)
  end)

  it('should execute extended query with recordset', function(done) async()
    local sql = "select $1::text as f1, $2::text as f2"
    local params = {'hello', 'world'}

    cnn:query(sql, params, function(self, err, recordset, count)
      assert.equal(cnn, self) assert_nil(err)
      assert.equal(1, count)
      assert.same({
        header = {{'f1', 'f2'}, {'string', 'string'}};
        {'hello', 'world'};
      }, recordset)
      done()
    end)
  end)

  it('should execute 2 extended query one by one', function(done) async()
    local sql = "select $1::text as f1, $2::text as f2"
    local params = {'hello', 'world'}

    local called = false
    cnn:query(sql, params, function(self, err, recordset, count)
      assert.equal(cnn, self) assert_nil(err)
      assert.equal(1, count)
      assert.same({
        header = {{'f1', 'f2'}, {'string', 'string'}};
        {'hello', 'world'};
      }, recordset)
      called = true
    end)

    params = {'hi', 'again'}
    cnn:query(sql, params, function(self, err, recordset, count)
      assert.equal(cnn, self) assert_nil(err)
      assert.equal(1, count)
      assert.same({
        header = {{'f1', 'f2'}, {'string', 'string'}};
        {'hi', 'again'};
      }, recordset)
      assert.truthy(called)
      done()
    end)
  end)

  it('should execute second extended query after prepare error', function(done) async()
    local called = false

    local sql = "select 1 form not_a_table where 1=$1"
    cnn:query(sql, {'1'}, function(self, err, recordset, count)
      assert.equal(cnn, self) assert.not_nil(err)
      called = true
    end)

    local sql = "select $1::text as f1, $2::text as f2"
    local params = {'hi', 'again'}
    cnn:query(sql, params, function(self, err, recordset, count)
      assert.equal(cnn, self) assert_nil(err)
      assert.equal(1, count)
      assert.same({
        header = {{'f1', 'f2'}, {'string', 'string'}};
        {'hi', 'again'};
      }, recordset)
      assert.truthy(called)
      done()
    end)

  end)

  it('should execute second extended query after execute error', function(done) async()
    local called = false

    local sql = "select $1::text as f1, $2::text as f2"
    cnn:query(sql, {}, function(self, err, recordset, count)
      assert.equal(cnn, self) assert.not_nil(err)
      called = true
    end)

    local sql = "select $1::text as f1, $2::text as f2"
    local params = {'hi', 'again'}
    cnn:query(sql, params, function(self, err, recordset, count)
      assert.equal(cnn, self) assert_nil(err)
      assert.equal(1, count)
      assert.same({
        header = {{'f1', 'f2'}, {'string', 'string'}};
        {'hi', 'again'};
      }, recordset)
      assert.truthy(called)
      done()
    end)

  end)

  it('should execute extended query with empty recordset', function(done) async()
    local sql = "select $1::text as f1, $2::text as f2 where 1=0"
    local params = {'hello', 'world'}

    cnn:query(sql, params, function(self, err, recordset, count)
      assert.equal(cnn, self) assert_nil(err)
      assert.equal(1, count)
      assert.same({
        header = {{'f1', 'f2'}, {'string', 'string'}};
      }, recordset)
      done()
    end)
  end)

  it('should execute extended query with rows affected', function(done) async()
    local sql = "insert into " .. TEST_TABLE_NAME .. "(f1, f2) values($1, $2)"
    local params = {'hello', 'world'}

    cnn:query(sql, params, function(self, err, recordset, count)
      assert.equal(cnn, self) assert_nil(err)
      assert.equal(1, count)
      assert.same({1}, recordset)
      done()
    end)
  end)

  before_each(function(done) async()
    cnn = pg.new(CONFIG)
    cnn:connect(function(self, err) assert_nil(err)
      ensure_table(self, done)
    end)
  end)

  after_each(function(done) async()
    if cnn then
      if cnn:connected() then
        drop_table(cnn, function(self)
          return self:close(function()
            done()
          end)
        end)
      end
      cnn = nil
    end
    done()
  end)

end)

describe('pg pubsub', function()
  local cnn

  it('should listen and notify with sql statement', function(done) async()
    local sql = "LISTEN virtual"

    cnn:query(sql, function(self, err, recordset, count)
      assert.equal(cnn, self) assert_nil(err)
      assert.equal(1, count)
      assert.same({}, recordset)

      local events = {}
      self:on('notify', function(self, event, pid, channel, payload)
        assert.equal(cnn, self)
        assert.number(pid)
        events[#events + 1] = {event, channel, payload}
      end)

      local sql = "NOTIFY virtual, 'hello world'"
      self:query(sql, function(self, err, recordset, count)
        assert.equal(cnn, self) assert_nil(err)
        assert.equal(1, count)
        assert.same({}, recordset)
        uv.defer(function()
          assert.same({
            {'notify', 'virtual', 'hello world'}
          }, events)
          done()
        end)
      end)
    end)
  end)

  it('should listen and notify with function with payload', function(done) async()
    local sql = "LISTEN virtual"

    cnn:query(sql, function(self, err, recordset, count)
      assert.equal(cnn, self) assert_nil(err)
      assert.equal(1, count)
      assert.same({}, recordset)

      local events = {}
      self:on('notify', function(self, event, pid, channel, payload)
        assert.equal(cnn, self)
        assert.number(pid)
        events[#events + 1] = {event, channel, payload}
      end)

      local sql = "select pg_notify('virtual', 'hello world')"
      self:query(sql, function(self, err, recordset, count)
        assert.equal(cnn, self) assert_nil(err)
        assert.equal(1, count)
        assert.same({
          header = {{'pg_notify'}, {'string'}};
          {''}
        }, recordset)
        uv.defer(function()
          assert.same({
            {'notify', 'virtual', 'hello world'}
          }, events)
          done()
        end)
      end)
    end)
  end)

  before_each(function(done) async()
    cnn = pg.new(CONFIG)
    cnn:connect(function(self, err) assert_nil(err)
      done()
    end)
  end)

  after_each(function(done) async()
    if cnn then
      cnn:close(function() done() end)
      cnn = nil
      return
    end
    done()
  end)

end)
